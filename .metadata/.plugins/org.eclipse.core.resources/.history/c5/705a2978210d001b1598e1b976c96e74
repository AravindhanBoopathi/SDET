package ds.arrays.string.assessment;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;

import org.junit.Test;

public class P003LargestString {

	/*
	 * Given a string, construct a new string by rearranging the original string
	 * and deleting characters as needed. Return the alphabetically largest
	 * string that can be constructed respecting a limit as to how many
	 * consecutive characters can be the same.
	 * 
	 * 
	 * 
	 */

	private String solution(String input, int k) {

		char[] strInput = input.toCharArray();

		Map<Character, Integer> map = new HashMap<Character, Integer>();

		for (char c : strInput) {
			map.put(c, map.getOrDefault(c, 0) + 1);
		}


		List<Entry<Character, Integer>> list = new LinkedList<Entry<Character, Integer>>(map.entrySet());
		// sorting the list elements
		Collections.sort(list, new Comparator<Entry<Character, Integer>>() {
			public int compare(Entry<Character, Integer> o1, Entry<Character, Integer> o2) {

				return o2.getKey().compareTo(o1.getKey());
			}
		});

		System.out.println(list);

		List<Character> output = new ArrayList<Character>();

		Entry<Character, Integer> currentEntry = list.get(0);

		while(currentEntry.getValue() > 0){			

			if(list.size()==1){
				int printTimes = currentEntry.getValue() > k? k:currentEntry.getValue();

				while (printTimes > 0) {
					output.add(currentEntry.getKey());
					currentEntry.setValue(currentEntry.getValue() - 1);
					printTimes--;
				}

				if(list.get(0).getValue() > 0){
					int lastSize = output.size();
					int index = (lastSize - k) - 1 ;
					
//					int count = 0;
					while(currentEntry.getValue() > 0){	
						try{
							System.out.println(currentEntry.getKey());
							System.out.println(output.get(lastSize));
							System.out.println(index);
							
							index = findIndex(lastSize, output, currentEntry.getKey());
							
							output.add(index , currentEntry.getKey());
							currentEntry.setValue(currentEntry.getValue() - 1);

//							count++;
//							if(count>1){
//								index--;
//								count = 0;
//							}

						}catch(IndexOutOfBoundsException e){
							break;
						}
					}
				}else{
					break;
				}
			}
			if(list.size()>1){

				int printTimes1 = currentEntry.getValue() > k? k:currentEntry.getValue();

				if(printTimes1 < k){
					while (printTimes1 > 0) {
						output.add(currentEntry.getKey());
						currentEntry.setValue(currentEntry.getValue() - 1);
						printTimes1--;
					}

				}
				else{
					while (printTimes1 > 0) {
						output.add(currentEntry.getKey());
						currentEntry.setValue(currentEntry.getValue() - 1);
						printTimes1--;
					}

					if (list.get(1).getValue() > 0) {
						output.add(list.get(1).getKey());
						list.get(1).setValue(list.get(1).getValue() - 1);

					}

					if (list.get(1).getValue() == 0) {
						list.remove(1);

					}
				}

				if (list.get(0).getValue() == 0) {
					list.remove(0);

				}
				if(!list.isEmpty()){
					currentEntry = list.get(0);
				}

			}


		}


		return output.toString();

	}
	
	public int findIndex(int lastIndex, List<Character> output, char currentChar){
		
		for(int i=lastIndex; i>0; i--){
		
			if(currentChar != output.get(i) 
					&& currentChar != output.get(i-1)){
				
			}
			
		}

		return 0;
	}

	@Test
	public void testData1() {

		String input = "baaaaaaaaacc";
		//		caacaabaa

		int k = 2;

		System.out.println(solution(input, k));

	}

	@Test
	public void testData2() {

		String input = "bbbbbbaccc";
		//		ccbcbbabb
		int k = 2;

		System.out.println(solution(input, k));

	}


	@Test
	public void testData3() {

		String input = "aazzzzc";
		int k = 2;
		System.out.println(solution(input, k));

	}

	@Test
	public void testData4() {

		String input = "aazzzzzzc";
		int k = 3;
		System.out.println(solution(input, k));

	}


}
